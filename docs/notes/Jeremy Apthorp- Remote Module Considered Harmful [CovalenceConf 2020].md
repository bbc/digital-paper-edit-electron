[Jeremy Apthorp: Remote Module Considered Harmful [CovalenceConf 2020]](https://youtu.be/0lb7AxaucZI)

> so Jeremy is one of my co-workers on the slack desktop runtime team and one of the main contributors to electron and today he'll be talking about the infamous remote module before I start I want to just take a moment to acknowledge that this beautiful place in which I'm lucky enough to live and in which we're meeting today is the unseeded traditional land of the Ohlone people who have cared for this place for millennia and who continue to care for this place today so hi my name is Jeremy or if you've seen me on github you might have seen the name nor Ngong I've been an electron maintainer since 2018 so about two years many years ago I worked on the chrome team on working on chrome packaged apps which is what eventually became pwace but I came to the dark side to work on electron and today I want to talk to you about IPC which stands for inter process communication so I'm just gonna start with a quick refresher on electrons process model so electrons based on chrome and Chrome puts each tab into a separate process so there's one controller process called the main process which is responsible for rendering the window frames and talking to the operating system but all the web' stuff like javascript and CSS happens in the renderer process so they're all related but the main process is in charge in chrome each render process roughly corresponds to a tab in electron which doesn't really have the idea of tabs there's roughly one renderer process per browser window ish there's a lot of reasons why this kind of separation is useful maybe the most user visible one in chrome is that when a tab crashes and when a website crashes or freezes it doesn't take down the entire browser but it also means that render process can be sandboxed and only be given access to the things that they're supposed to have access - so when a renderer process wants to make a network request for instance it doesn't have the access in the operating system to do that by itself so what it does instead is it sends a message to another process the main process saying hey can you make this request for me to like HTTP colon slash slash my bank comm and then the main process says decides whether or not that product that who made that request should be allowed to do that or not so it says well your origins the same you know other the cross origin resource sharing headers here present in this resource and then if so it creates the socket connects and passes all that information back to the renderer process so the main process is acting on behalf of the renderer which means it's in control it gets to decide what is and isn't allowed and this is a really important security principle for chrome okay so back to electron how does IPC work in electron every way of sending messages between processes and electron is based on these two primitives IPC render an IPC main so these are two halves of the same API where IPC renderer is the part that's in the renderer and IPC main is the part that's available in the main process so anything that sends messages between processes in electron is built on these two primitives including the remote module which I'm getting to so this is how these api's work you can register an event handler on one side in this case on the main process side and then send a message from the other side which will cause the event handler to fire in the other process and it'll pass along this event object which includes a bunch of information about that event most importantly where it came from and sending messages the other way works about the same and you also get any data any arguments that were passed along with that message sending messages from the main process of the renderer process is a little bit more complicated because you have to know which render process you want to send to since there could be more than one where is there's only one main process okay but what about the remote module that was in the title of the talk so somewhere regrettably there are a lot of tutorials and guides for electron that suggest that you use the remote jewel for IPC and I say regrettably because this recommendation turns out to be a bit of a poisoned chalice the remote module promises like a lot of power and convenience like you're gonna be you're gonna be served powerful if you drink this just problem it's fine so but yeah but at what cost so before I get into why you shouldn't use it let me say a little bit about what it is and how it works so its remote is a built-in module in electron and it's only accessible from the renderer process and what it does is lets you pretend that a JavaScript object that lives in the main process is accessible directly in the renderer process as if it were local so for example here's a snippet of JavaScript that launches an HTTP server from the renderer process and this will work fine even if node integration is turned off in the renderer process so this server is actually running in the main process that's what opened the socket but any time it receives a request it'll send a message over to the renderer process say like hey what should I do with this request and then and then the renderer process will call functions and and sort of drive it so although the logic is happening in the renderer but all of the actual HTTP things is happening in the main process so this is pretty cool under the hood this is all implemented using IPC main an IPC renderer just like I said along with proxy objects so a proxy object is a JavaScript object whose behavior you get to choose and you get to define how this javascript object works by writing more JavaScript JavaScript in your JavaScript so for example when you access a property on a remote object or on a proxy object what we're gonna do is send a synchronous IPC message so we're gonna call IPC main set or IPC renderer send sync so that's gonna block the renderer process and send a message over to the main process saying like hey you know please please tell me what the problem the value of this property is and then when we get the reply back we'll return that back to the caller who accessed the property so for instance if I call some remote object a property that's going to result in a sense Inc happening and if we get back another object instead of returning that object directly we're going to return another proxy object so that chaining works properly there's also like a little bit of extra magic juice that has to be in C++ because we don't have a weak ref that hooks into the garbage collector to make sure that if you hold a reference to an object through the remote module in the renderer process that the main process won't garbage collect that and disappear it so the illusion is pretty convincing things look and feel as if they're local in the renderer process even though they're not but there are a few problems the first is that it's slurred like really slow so imagine you're baking a cake and you ran out of sugar and you're gonna go ten minutes down the shops and get a bag of sugar and then ten minutes back if you are using the remote module to get sugar it would take you six months if you started baking your cake in winter you'll be back at your kitchen in summer so that's like a long time on my machine accessing a property on a remote object takes about 100 microseconds of 0.1 millisecond accessing a property on a local object takes 0.01 micro seconds as ten thousand times faster to access something locally than it is to go over IPC okay but like computers are really fast 100 microseconds is still pretty quick you get like 160 of those in a frame if you're at 60 frames per second so that's okay if you're just accessing one or two things but the way the remote module is built so that it looks as if it's local it's really easy to unintentionally be accessing the remote object like many many times in order to do simple things and resulting in a lot of IPC round traps so here's a example of a little API in the main process we have a thing the thing has a rectangle we can get the bounds and set the mounds of the rectangle and what we want to do we're in the renderer process and we want to make the that tanga 100 pixels bigger so we grab the global remote don't get global and we're going to D structure that get the X Y width height properties and add 100 and set the bounds so doing this takes 9 IPC round trips or nearly a full millisecond on my machine first we're gonna get the global which returns the proxy object that's controlled by remote then we grab the rectangle which is another proxy object and we grab the bounds of the rectangle which is yet another proxy object so we've got three proxy objects now now we have to fetch each of the four properties of the object so that's four more IPC's sent and received finally we grab the rectangle again and call set bounds so that's nine IPC round trips in this code that doesn't look like it has any sort of performing this is very straightforward code there's just like two function calls in addy structuring so this can be really hard to spot in your code and in this particular case like now that I've identified it and pointed it out it's obvious that we could like improve this somehow like we could return the X Y width height as a as a string and then that would only be one round trip instead of having to send Andres receive like one for each property or we could add a function that if we controlled this API we could add like an increase height function which would just be one round trip but the problem is that because the remote module is so convenient these things it's it's really easy to miss subtle performance problems like this and if that wasn't enough of a headache already there's also the fact that each of these remote calls is a synchronous IPC so it blocks the entire renderer process whenever there's a remote call happening so that's no scrolling or CSS animations no nothing while one of these render remote objects is in an IPC Cole I'm told it's important to put pictures of cute animals in your presentations so here's a fruit bat eating a slice of watermelon [Music] yeah pretty good okay so it's slow what else one out of every 100 times you run some pieces of code that you use remote they fail okay let me let me explain here's here's like a JavaScript pattern that is pretty common so what we're gonna do is we're gonna tell an object to do some sort of asynchronous thing in this case connect and then we're gonna register an event listener saying like hey okay when you're connected when you've done that asynchronous thing like I'm gonna do something else so let me know and I'm gonna trigger some something to happen off to it and this is guaranteed to always work in JavaScript because we know that that event can't be triggered until after this current like thread has finished running because javascript is single threaded right so we're guaranteed that the event can't be emitted before we're able to register a listener but if obtuse a remote object then this doesn't if this is not true if connect ever takes less time than the time that it takes it to send to IPC messages so that's about 0.2 milliseconds or but a lot higher if your machine is under heavy load if it's busy doing other things then the event will appear to never trigger and I can tell you from experience that this is really really hard to debug um here's a complicated diagram that illustrates this but actually I want to get to volunteers from the audience if you can fold a piece of paper in half raise your hand all right do what you want to come up I have some props here to help me out some IPC messages come on up going up is this one it is fantastic okay I can leave my little thin over there what are your names Brian nice to meet you and Scott great to meet you thanks yeah can we get a round of applause for our volunteers okay come over this way a little bit come out from behind the podium okay so I have two IPC messages here one says fold me I'm gonna hand that to you Brian not just yet so you're gonna I'm gonna be the renderer process Brian here is going to be the main process and Scott's going to be the asynchronous task what's happening so when I pass you this this message fold me I want you to give that to the asynchronous task to Scott and Scott what I want you to do is fold it there's three just fold it in half three times and then give it back to Brian that's all you have to do just full yeah it's got like little lines to help you and it says on it what to do sir if you forget it should be fine okay Brian so when I when I give you this fold me message just hand it over to Scott that's all you need to do and then I'm gonna give you this little basket and our goal here is to get the folded piece of paper in the basket so if you receive back the folded piece of paper and you're holding the basket put the folded piece of paper in the basket and give it back to me if you're not holding the basket and you got to fold a piece of paper just drop it on the floor okay so we got it we got what we're doing okay okay so main process can you fold this for me a mean process can you tell me when the piece of paper is folded awesome great that worked fantastic occurred forks thank you we have one more to do I'm gonna unfold this and we're gonna try one more time okay hey main process can you fold this piece of paper for me one second hey main process can you tell me when you get the piece of paper okay sir thank you thank you sick can we get a round of applause that was fantastic thank you thanks God thanks friend really appreciate it okay so you don't have to look at this diagram there also like a bunch of other like subtle differences in behavior between remote objects and non remote objects most of the time these don't come up but when they do and they will eventually as your app grows and you get more developers working on it it can be really confusing and difficult to debug so they're all these subtle differences okay so it's slow and it's easy to accidentally write race conditions it's also a gaping security hole so the remote module represents a huge potential for security issues if your sandboxing your app which you should be doing as you heard from a bunch of people today already but you're not also disabling the remote module and then this is kind of what your sandbox looks like if the renderer process can manage to send this IPC message to the main process then they have all the privileges that the main process has if you turn off their remote module in a particular process then and the main process get this IPC call it'll just throw it on the ground and ignore it so if you want to run any kind of code that you don't trust completely then you need to be turning off the remote module okay but my app doesn't load any untrusted code I'm safe right well do you load any images and PNG is a code sometimes but also JSON sir yeah so I'm the electron team we looked at all these problems with the remote module and we decided that we can't really in good conscience recommend that people use it we've seen a lot of large apps including slack make the decision to remove their usage of their module entirely it's not worth the ease initially and it's it's a lot it's very difficult to remove the remote module from your app once you've been using it for a while so it always ends up turning out to have been a bad idea to start with you start using the remote module and refactoring it is really expensive so we're gonna deprecated the remote module in electron it's not gonna happen overnight thank you okay one chip one person's excited about deprecating there so it's not happening overnight and where you're still going to be able to use the remote module indefinitely if you decide that it's right for you just gonna get a little trickier to use so in electron 9 we're gonna stop printing a deprecation warning if you use the remote module without enabling it like this in the web preferences and then starting in electron 10 an able remove module is going to become false by default so if you want to use the remove module you have to enable it explicitly once we've disabled the remote module by default we're gonna build a version of the remote module that functions as a regular JavaScript library that you can npm install and once that's working well we're gonna stop printing a deprecation warning when you use the built-in version that's gonna direct you towards the userland version of remote and once we've printed that once we've had the version that prints that deprecation warning we'll remove it in the following version and I don't know exactly what version of electron this is going to be yet because it depends on a v8 feature that Shelly talked about this morning called weak refs being shipped and I don't know when that's going to ship so we depend we're gonna depend on that for the user land version of remote and there's a bug that's pinned on the electron github repo if you go and check it out there's a bug that's is deprecated or McMullan that has all of this info unit two so to be clear if despite my warnings you still like the remote module and you want to keep using it you will absolutely be able to the only difference is that you'll have to require it from an NPM instead of from electron the goal of deprecating it and moving it to a third-party repository is to make it clear that remote is just one of a lot of different ways that you could choose to start your IPC in your app and it might not be the best way okay so if you're not supposed to use the remote module what should you be doing instead the first thing is see if you can get away without doing any IPC at all as often it's the case the bit of code that's running in the renderer process doesn't have any particularly good reason to be in the renderer process stuff like setting up a menu and that can be moved to the main process instead without any trouble if you're liking so if you can do that that's great or you might be able to do it the other way around as well find a bit of code that's running in the main process that has no particular reason to be there and you can move it to the renderer process where it is called that's even better where it's possible because it frees up the main process to do other things if you really need to send an IPC message to the main process from the renderer and get a response there's an API in electron version 7 and later called IBC renderer invoke and this lets you carve out like an IPC method that's just for you the and so you can use this to expose just what the renderer needs additionally it's asynchronous so it returns a promise so it's not gonna block the renderer process and it makes it really obvious when IPC is happening so it can be a lot easier to debug any sort of IPC related issues so the TLDR of this talk is if you want your app to be faster and more secure and more understandable you should avoid the remote module you should think carefully about when you're sending IPC messages and make sure you're only exposing the minimum capabilities that the renderer needs to do its thing also sandbox your app so thanks everyone for listening you know please like and subscribe I I've wrote most of these thoughts down in a medium post you can just get a medium to calm slash nor know gone and you'll get most of this information and you can follow me i'll mastodons over there thanks i think we have time for questions jeremy we do have time for questions and seems like there's a lot over there so one thing we like the remote module for is that it provides you a guarantee that somebody on the other side of IPC is listening to your function calls it also provides us like a strict interface we use typescript so we're able to like import those types over how do you manage those kind of problems in slack if you're using invoke I actually can't speak on behalf of slack because I don't know how the slack app works kind of embarrassing but we're still in the Protestant the process of removing remote so we have we're still figuring this stuff out one thing that we did look at was there's a library called comlink which is designed for talking between web workers and like a main webpage that is that addresses some of these problems if you have more complex IPC needs ideally you would not need that because the your IPC surface should be relatively small the larger your IPC surface is more difficult it is to audit and there can be like serious security bugs hiding an IPC so yeah I guess the answer that I have is that I don't have a good answer I'm actually a little surprised that typescript works well with the remote module how does how do you so we have like a set of services defined in the main process and they have a type and we're able to create like an object that defines and then we can just import the type because the type is just a type that's sure so exactly at it offers remote then you cast it in the taiga yeah yes that makes sense yeah cool thanks thanks I was also curious about the ergonomics around typescript but that was asked and answered so the other question I had was we use IPC you send a message and you see multiple responses based on like the status of whatever the process is running in main potentially and we're now using a book which is great but wondering if there's any thought around like chaining and boat calls so that you could like receive multiple promises in response and await them in different orders and used as a loading indication yeah that is a great question so invoke has only only supports a request response model so it's fairly straightforward in that and the only way that I know currently to do like a screen streaming results where you get more than one result is to use at the underlying features of IPC render don't send and receive and then you'll have to manage channels yourself and assign IDs and so on so that's definitely something that we could improve on I think that it would make sense to have something to return a generator and so you would be able to use like async generators to receive multiple responses I think that would be awesome and I would love to see that PR I guess I'm next so I I store my global variables in main and then all the renderer processes call that to get access to those Global's how will I do that without remote so you weren't the way to do that is to figure out what things you need to expose and produce wrappers around them using invoke so you within work you register a handler say IBC main dot handle and you say a channel and like just a string and then you call invoke with that string on the renderer process and your function in the main process will get called so and won't all applications have to recreate that very same thing over again that's what IPC renderer invoke is therefore so the idea is that use any functionality that needs to be accessed over IPC from the renderer process assuming that it fits the request response model here which like 99% of the time it is what that's what we needed you'll be able to register a handler using IPC main dot handle and get there get the value back using invoke so it's definitely more work to do then then it is with the remote ai ai ai want things to be easier and I'm and definitely open to hearing like ideas for how to do that there has to be a balance though between I think the remote module went too far on like pretending that it is a local object and that makes things really hard to audit and and also isn't always true so I think we need to strike a balance maybe IPC renderer invoke is kind of too far down there like difficult path and people will just go reach for a remote but I would like to sort of like understand why people are doing that on a on a deeper level and see if we can provide tools in electron that allow people to build more secure and performing ipeec great thanks there are any other questions we have one over here thank you so how do you recommend that to render a process to communicate with each other so currently we are using send to but I read that Center will also go through the main process so that's that is a fantastic question I have been playing around with some prototypes of ways to do that there's currently a proposal in the API working group for a method to do that that's built on message channels and message ports which is a Web API that you can use to talk between like web worker and I mean on a main page so that's that's what the current proposal is the so to answer your question directly there's no way to talk to directly render to render without using a native node module in electron today I think there should be and I'm excited to like build that and like have so I've heard a lot of people wanting to use that in their apps so yes that will exist hopefully Thanks are there any performance concerns around like size of payloads for IPC messages going back and forth like you're moving a large amount of data yes the way that all of those IPC has methods at least in electron 7 and up work is via the structured clone algorithm which is a serialization method so whenever you send an object over IPC and this is also the case with remote to some degree it gets serialized into data so that means reading out the whole structure writing it into a buffer and then like copying that into a pipe I mean so the larger your it's like order n it's like this the larger your buffer is the longer it's going to take to transmit there are a couple ways around this involving shared memory the so if you want to send something like video buffers video frames there are I know that some people are using a shared memory to do that and there's also I have been exploring being able to use like movable buffers so that's like being able to like take a buffer and like just send a handle to it like marketers shared memory and just send the handle over and there is some like this is called transferable Xin web terminology we don't currently support them in electron but I would like to and that's also part of that proposal that I mentioned about the sending messengers render to render it that would also extend to render at the main process and it would work more like post message thank you any more questions and okay well thank you very much Jeremy here [Applause]
